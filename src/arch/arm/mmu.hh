/*
 * Copyright (c) 2012-2013, 2015 ARM Limited
 * Copyright (c) 2018 Metempsy Technology Consulting
 * All rights reserved
 *
 * The license below extends only to copyright in the software and shall
 * not be construed as granting a license to any other intellectual
 * property including but not limited to intellectual property relating
 * to a hardware implementation of the functionality of the software
 * licensed hereunder.  You may use the software subject to the license
 * terms below provided that you ensure that this notice is replicated
 * unmodified and in its entirety in all distributions of the software,
 * modified or unmodified, in source code or in binary form.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met: redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer;
 * redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution;
 * neither the name of the copyright holders nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Thomas Grocutt
 *          Ivan Pizarro
 */

#ifndef __ARCH_ARM_MMU_HH__
#define __ARCH_ARM_MMU_HH__

#include "arch/arm/faults.hh"
#include "arch/arm/table_walker.hh"
#include "arch/arm/tlb.hh"
#include "arch/arm/utility.hh"
#include "dev/dma_device.hh"
#include "mem/request.hh"
#include "params/ArmMMU.hh"
#include "sim/eventq.hh"

namespace ArmISA {

class MMU : public BaseMMU
{
    friend class TLB;
    friend class TableWalker;

    private:

        std::vector<TLB*> stage1_tlbs;
        std::vector<TLB*> stage2_tlbs;

        std::vector<TableWalker*> stage1_walkers;
        std::vector<TableWalker*> stage2_walkers;

    protected:

        /** Request id for requests generated by this MMU */
        MasterID masterId;

        enum ArchVersion {
            ARMv8p0,
            ARMv8p1,
            ARMv8p2
        };

        /** Returns TRUE if the implemented architecture includes the
            extensions defined in the specified architecture version */
        bool hasArchVersion(ArchVersion version);

    public:

        /** This translation class is used to trigger the data fetch once a
            timing translation returns the translated physical address */
        class Stage2Translation : public BaseTLB::Translation
        {
          private:
            Addr      descAddr;
            uint8_t   *data;
            int       numBytes;
            RequestPtr _req;
            Event     *event;
            MMU       &parent;
            Addr      oVAddr;
            bool      isfetch;
            TLB*      stage2tlb;
            TableWalker::WalkerState* walkerState;
            TableWalker::MemSidePort* port;

          public:
            Fault fault;

            Stage2Translation(MMU &_parent, Addr _descAddr, uint8_t *_data,
                RequestPtr req, Event *_event, Addr _oVAddr, bool isfetch,
                TableWalker::WalkerState*, TableWalker::MemSidePort*);

            void
            markDelayed() {}

            void
            finish(const Fault &fault, const RequestPtr &req,
                    ThreadContext *tc, BaseTLB::Mode mode);

            void
            setVirt(Addr vaddr, int size, Request::Flags flags, int masterId)
            {
                numBytes = size;
                _req->setVirt(0, vaddr, size, flags, masterId, 0);
            }

            void
            translateTiming(ThreadContext *tc)
            {
                stage2tlb->translateTiming(_req, tc, this, BaseTLB::Read);
            }
        };

        /** Perform a stage 2 translation. It will use the cached values in the
            TLB if a valid entry is found, issue a table walk if not */
        Fault secondStageTranslateUntimed(TLB::TranslationState*, Addr,
                uint8_t*, int, Request::Flags, bool, TableWalker::MemSidePort*,
                MasterID);
        void secondStageTranslateTimed(ThreadContext*, Addr,
                Stage2Translation*, uint8_t*, int, Request::Flags, MasterID);

        /** Returns the implementation defined upper limit on the physical
            address size for this processor, as log2() */
        int PAMax(ThreadContext*);

        /** Return TRUE if the extensions or granule sizes are enabled in the
            current translation context */
        bool have52BitVAExt();

        /** Return the MSB of a virtual address in the stage 1 translation
            regime for "el". If EL1 is using AArch64 then addresses from EL0
            using AArch32 are zero-extended to 64 bits */
        int addrTop(ThreadContext*, Addr, bool, ExceptionLevel, HCR, TTBCR);

        /** Stage 1 translation regime for the given Exception level */
        ExceptionLevel s1TranslationRegime(ThreadContext*, ExceptionLevel,
                                            HCR);

        typedef ArmMMUParams Params;
        MMU(const Params *p);
};

} // namespace ArmISA

#endif //__ARCH_ARM_MMU_HH__
